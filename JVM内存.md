### JVM内存

#### 程序计数器：Program counter Register

1. 线程私有
2. 较小内存
3. 当前线程所执行的字节码的行号指示器
4. 通过改变计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等功能都依赖其实现
5. 当执行的是Java方法时，计数器是正在执行的虚拟机的字节码指令的地址
6. 当执行的是Native方法时（本地操作系统方法）时，计数器值为空，
7. 不会出现OOM

#### Java虚拟机栈：Java Virtual Machine Stacks

1. 线程私有
2. 生命周期与线程相同
3. 描述的是Java方法执行的内存模型，是用于支持虚拟机进行方法调用和执行的数据结构

   + 每个方法被执行的同时，都会同时创建一个栈帧。
   + 活动的线程中，只有栈顶的栈帧是有效的，称为当前栈帧
   + 当前栈帧关联的方法，称为当前方法  （一个线程中，有多个方法）
   + 执行引擎所运行的所有的字节码指令，只针对当前栈帧进行操作。
4. ​栈帧存储：局部变量表、操作数栈、动态链接、方法返回地址、额外的附加信息 
5. 在编译程序代码时，栈帧需要多大的局部变量表、多深的操作数栈已完全确定，并写入方法表的Code属性中
6. 栈帧需要分配多少内存，不受程序运行期变量数据的影响，而仅仅取决于虚拟机的实现。
7. 如果线程请求的栈深度大于虚拟机所允许的深度、抛出 StackOverFlowError异常
8. 如果虚拟机在动态扩展栈时，无法申请到足够的内存空间，则抛出OutOfMemoryError异常


##### 局部变量表

一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据类型是编译期可知的各种基本数据类型、对象引用及 returnAddress类型（指向一条字节码指令的地址）

编译期：在Java程序被编译成Class文件时

当进入一个方法时，方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

* 局部变量表的容量以变量槽（slot）为最小单位，但在虚拟机规范中未明确指出一个slot占多大内存
* 虚拟机通过索引定位的方式使用局部变量表，索引值从0开始到局部变量表的最大slot数
* 在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是实例方法，则局部变量表中的第0位索引的slot默认是用于传递方法所属对象实例的引用，在方法中，通过this来访问这个隐含的参数，其余参数按参数表顺序排序，参数表分配完毕后，再根据方法体内部的变量顺序和作用域分配其余slot
* 局部变量表中的slot可重用，方法体中定义的变量，作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量的slot就可以 交给其他变量，这样的设计不仅是空间的节省，也会影响到系统的垃圾回收机制。

##### 操作数栈

* 最大深度在编译时已确认，32位数据类型栈容量为1，64位操作类型栈容量为2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令向操作栈中写入和提取内容，
* Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中栈指的是操作数栈
* 基于栈的优点：可移植性强，
* 基于栈的缺点：速度慢

##### 动态链接：

* 每个栈帧都包含一个指向运行时常量池中（方法区）该栈帧所属的方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。Class文件的常量池中存在大量的符号引用。
* 字节码中方法调用指令就以常量池中指向的方法的符号引用为参数
* 符号引用，一部分是在类加载阶段或第一次使用的时候转化为直接引用（final 、static），称为静态解析；另一部分将在每一次的运行期间转化为直接引用，这部分称为动态链接


##### 方法返回地址

* 当一个方法被 执行后，有两种方式退出方法：

  1. 执行引擎遇到了任意一个方法返回的字节码指令
  2. 执行 引擎遇到了异常且该异常没有在方法体内得到处理

* 无论何种方式退出，都需要返回到方法被调用的位置，程序才可以继续进行，

* 方法返回时，可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态，

  1. 正常退出时：调用者的PC计数器的值可以作为返回地址，栈帧中很可能保存这个计数器值
  2. 方法异常退出时：返回地址是通过异常处理器来确定，栈帧 中一般不会保存这部分信息。

* 方法退出的过程，相当于栈帧出站，因此退出时可能执行的操作：恢复上层方法的局部变量表、操作数栈，如果有返回值，则把它压入调用者栈帧的操作数中，调整PC计数器的值 以指向方法调用指令后面的一条指令。


#### 本地方法栈（Native Method Stacks）

与虚拟机栈作用类似，只是虚拟机栈为执行虚拟机执行Java方法服务，则本地方法栈则为使用到本地操作系统（Native）方法服务

JNI调用实现本地主法

#### Java堆（javaHeap）

* Java虚拟机中所管理的内存中最大的一块
* 所有线程共享
* 几乎所有的对象实例和数组都从这块分配内存  （什么不在堆中？Integer? 前128？）
* GC管理的主要区域
* 物理上可不连续，只要逻辑上是连续的即可
* 如果没有内存可分配，且无法扩展时，将会抛出OutOfMemoryError异常

#### 方法区：

* 线程共享
* 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
* 又被称为永久代（Hotspot）
* 不需要连续的内存，可以选择固定大小或可扩展
* 不实现垃圾回收
* 该区域内存回收，主要针对废弃常量和无用类的回收，
* 运行时常量池，属于方法区的一部分。
* 运行时常量池存储：
  1. Class文件常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存到方法区的运行时常量池中。
  2. 相对Class文件常量池，运行时常量池具备动态性
  3. java 语言不要求常量一定只能在编译期产生，即：并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量，运行期也可能将新的常量放入池中，利用较多的是String类的intern()方法
  4. 会抛出OutOfMemoryError异常
####直接内存

不是虚拟机运行时的数据区的一部分，直接从操作系统中分配、因此不受java堆大小的限制，但是会受本机总内存的大小及处理器寻址空间的限制，可能会出OutOfMemoryError




